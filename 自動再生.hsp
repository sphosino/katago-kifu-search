#include "go_game_manager.hsp"
#include "開発完了/katago_sqr.hsp"
#include "開発完了/keyfps.hsp"
#include "開発完了/listbox.hsp"
#include "GobanPatternManager.hsp"
#include "Search_pattern.hsp"
#include "hspext.as"

dirname = "C:/Users/owner/Desktop/hsp/棋譜"
screen 0, 640,580
objsize 80
pos,80

time = 1000
input time
v = ""
jidou = 0
着手番号表示 = 0

chkbox "自動再生", jidou: chk_ID = stat
chkbox "着手番号", 着手番号表示

set_treeview 50,50
tree_direction = 6

input tree_direction

newmod t, treebox
newmod kifulist, my_listbox, 0,300,200,120
newmod matchlist, my_listbox, 0,450,200,120
	chdir dirname
	dirlist files,"*.sgf"
	add_item kifulist, files
topnode = -1
rn = 0
dim rect, 4
dim rect_stack, 4
newmod board, goban, 19,19,20,20,200,100

button gosub "SGFを読み込む", *loadfile
button gosub "SGFをコピー", *getsgf
button gosub "碁盤をクリア", *clearboard
button gosub "パターン生成", *create_pattern
chkbox "矩形生成",mode

gosub*loadsgf

pretime = keyfpstime

*main
	manage_keyfps

	nownode = get_current_node(t)
	
	getBoardCoordinates board, point

	in_board = 0
	if 0 <= point && point < 19{
		if 0 <= point.1 && point < 19{
			in_board = 1
		}
	}

	//マウス操作
	if _getkey(2) == 1{ //右クリック
		if treebox_onmouseid(t) >= 0{
			set_current_node t, treebox_onmouseid(t)
			Treebox_toggle_openflag t, treebox_onmouseid(t)
		}
		if mode == 0{//矩形描画モード
			if rn > 0{
				rn--
				modify_coordinates_by_rect v, rect_stack(0,rn), rect_stack(1, rn), rect_stack(2, rn), rect_stack(3, rn), 1
			}
		}
	}
	if _getkey(1) == 1{ //左クリック
		if listbox_on_id(kifulist,mousex, mousey) >= 0{
			itemid = stat
			items = get_listbox_item_list(kifulist)
			notesel items
			noteget s, itemid
			noteunsel
			topnode = change_sgf(s, t, board)
		}else{
			dragging_flag = 1
			get_treeview_position tmp
			dragstartx = mousex - tmp
			dragstarty = mousey - tmp.1
	
	
			if mode = 0{//矩形描画モード
				if in_board{
					rect = point,point.1,point,point.1
				}else{
					rect = -1
				}
			}else{
			
				if treebox_onmouseid(t) >=0{
					logmes "select_SGFID== "+stat
					
					set_current_node t, stat
		
				}else{
					if in_board{
						着手 board, point, point.1
						
						if stat{　//着手成功
							dragging_flag = 0
						
							make_SGFnode nownode, point, get_turn_SGFstr(逆手番(get_turn(board)))
			
							new = stat
			
							if new != nownode{
								Treebox_InsertItem t, new, nownode
								if nownode == -1: topnode = new
							}
							set_current_node t, new
						}
					}
				}
			}
		}
	}

	if dragging_flag{
		
		if mode = 0{
			rect(2) = limit(point(0),0,18)
			rect(3) = limit(point(1),0,18)
		}else{
			set_treeview_position mousex - dragstartx, mousey - dragstarty
		}
		
		if _getkey(1) == -1{//マウスが離されたとき
			
			dragging_flag = 0
			if mode = 0 && rect(0) >= 0{
				modify_coordinates_by_rect v, rect(0), rect(1), rect(2), rect(3)
				rect_stack(0,rn) = rect(0), rect(1), rect(2), rect(3)
				rn++
				dim rect,4
			}
		}
	}

	//マウスホイール
	mw = mousew
	if listbox_on_id(kifulist,mousex, mousey) = -1{
		if mw < 0 : gosub*move_next
		if mw > 0 : gosub*move_back
	}else{
		if mw < 0: move_scroll_index kifulist,1
		if mw > 0: move_scroll_index kifulist,-1
	}

	//キー操作
	if _getkey(17) >= 1{ //CTRL
		if _getkey('C') == 1 { //CTRL + C
			gosub*getsgf
		}
		if _getkey('V') == 1 { //CTRL + V
			gosub*loadsgf
		}
	}

	//自動再生
	if jidou & pretime + time <= keyfpstime{
		
		gosub *move_next
	}
	
	if prenode != nownode{
		prenode = nownode
		//ツリービューからSGFノードのIDを取り出して盤面作成
		make_board_from_sgf board, nownode

		if nownode >= 0{
			tmp = get_property_data(get_tree_item_id(nownode), "C")
			split tmp," ", c_list
		}
	}

		a = double(c_list) * 255
		color a,a,a
		boxf 0,80,640,ginfo(13)
		碁盤表示 board , 着手番号表示
		draw_set_list_on_board board, v
		set_tree_direction tree_direction
		treebox_draw t, topnode
		my_listbox_draw kifulist
		my_listbox_draw matchlist

		if dragging_flag && rect >= 0:碁盤に矩形データを表示 board, rect
	redraw: redraw 2

	goto*main
*clearboard
	clear_board board
	treebox_clear t
	topnode = stat
	return
*getsgf
	get_node_sgf topnode, a
	clipset a
	return
*loadsgf
	sdim s, $FFFF
	clipget s, varsize(s)
	if load_sgf(s,-1) < 0: return
	topnode = load_sgf_set_board(t, stat, board)
	return

*create_pattern
	initialize_rects v,r, stones
	
	repeat load_stones_from_board(board, n)
		add_stone_pattern r, stones, n(0,cnt), n(1,cnt), n(2,cnt)
	loop

	create_pattern_with_rects_and_stones r,stones,p

	logmes patterns_to_notepad(p)

	search get_name_all_items(kifulist), p, search_result

	logmes "@@\n" + search_result + "@@"
	
	return
	
*loadfile
	
	棋譜取得 dirname, 20 // katagoホームページから最新棋譜をダウンロード
	notesel files

	chdir dirname
	dirlist files,"*.sgf"
	add_item kifulist, files

	notesel files
	sortnote files,1
	noteget s,0

	topnode = change_sgf(s,t,board)
	
	return

#defcfunc load_sgf_set_board var _treebox, int node, var _board
	//SGFからツリー作成
	load_from_SGF_topnode _treebox, node
	sgf_topnode = node
	set_board_topnode _board, sgf_topnode

	return sgf_topnode

#defcfunc change_sgf str s1, var _treebox, var _board
	

	if get_value(s) == NOT_DEFINED_HASH{
		notesel sgf_data
		noteload s1
		noteunsel
		
		if load_sgf(sgf_data,-1) >= 0{
			new_topnode = load_sgf_set_board(_treebox, stat, _board)
			new_value s1, str(topnode)
		}else{
			dialog "SGF_FILE解析エラー",,__FILE__
			end
		}
	}else{
		new_topnode = int(refstr)
		logmes "SGF_NODE -> " + new_topnode
		set_board_topnode _board, new_topnode
		load_from_SGF_topnode t, new_topnode
	}
	
	return new_topnode

*move_next
	if nownode < 0: return

	set_current_node t, get_tree_root_child(nownode)
	if stat: treeview移動 1
	pretime = keyfpstime

	return
	
*move_back
	if nownode < 0: return
	if get_tree_parent(nownode) != -1{
		set_current_node t, get_tree_parent(nownode)
		pretime = keyfpstime
		treeview移動 -1
	}
	return

#deffunc treeview移動 int d
	get_treeview_node_size ns 
	if (get_tree_direction() & 1){
		move_treeview_position , ns.1 * -(((get_tree_direction() & 2) != 0) * 2 - 1) * d
	}else{ 
		move_treeview_position   ns   * -(((get_tree_direction() & 2) != 0) * 2 - 1) * d
	}
	return