#packopt name "search_process"
#include "nodmod/ProcLinkModule.hsp"
#include "modules/rotate_coordinate.hsp"
#include "../hsp_common/id_manager.hsp"
#include "modules/bitboard.hsp"
#include "basic.hsp"
#include "modules/sgf.hsp"
#include "../hsp_common/hash.hsp"
#include "../hsp_common/set.hsp"
#include "modules/search/pattern.hsp"
#include "modules/search/Search_pattern.hsp"
#include "メッセージ定数.hsp"

screen 0,640,480
gsel 0,-1
view_window = 0

init_sgf_module 10000

enable_auto_adjust
set_target_wait 30
delkey_all
addkey 27, 1


#ifdef _debug
	dirname = "C:\\Users\\owner\\Desktop\\katago-kifu-search"
#else
	dirname = dir_exe
#endif
chdir dirname

sdim kifulist //担当する棋譜のリスト
sdim result
newmod filename_to_topnode, hash_manager //棋譜ファイル名に、ノード展開を行った後のトップノード番号を紐づける

dim board, 26, 26
sdim v, 26 * 26 * 5
sdim group, , 4
sdim tejun, , 9

///////////////////////通信設定
// 設定読み込み
notesel s
	noteload "app_name.txt"
	// なごコネに参加。参加しなくても読み書きは可能だが、(親が離脱を感知できるようにするため）
	noteget app_name, 0
	nocoConnectAccept app_name  // グローバルアクセス空間に
	noteget h, 1
	parent_hwnd = int(h)
noteunsel
chdir "棋譜"
// 自動受信設定
nocoAutoCopyData //自動ジャンプを設定（ジャンプのタイミングでモジュール内部で受信内容が保存される
nocoOnCopyData *dummy 
oncmd gosub *on_copydata, stat

kifulist = make_new_set()

// メッセージ待機
repeat
	manage_keyfps
	exist_parent = 0
	repeat nocoConnectInfo(0)
		if nocoConnectInfo(1, cnt) == parent_hwnd{
			exist_parent = 1
			break
		}
	loop
	if exist_parent = 0: end
	if _getkey(27) == 1: view_window ^= 1: gsel 0, view_window*2-1
loop
*dummy
	return
*on_copydata
	
    // データ受信処理
    if 割り込み:割り込み = 0:return //repeatを抜ける
    
    // メッセージを受信したら
    count = nocoCopyDataInfo(0) //受信された回数（これが変化したらデータあり）
    param = nocoCopyDataInfo(3)  // 受信した整数値を取得
    data_size = nocoCopyDataInfo(4)  // データサイズを取得
    
    // パラメータで処理を分岐
    switch param

	case 担当棋譜　//担当すべき棋譜のリストが送られてきた

	nocoGetCopyData received_list
	notesel received_list
		repeat notemax
			noteget a, cnt
			push_data kifulist, a
		loop
	noteunsel
	
	swbreak

    case 検索実行

	nocoGetCopyData received_params //親プロセスからの検索パラメータを受け取る
	
	
	//検索条件を取り出す
	max_depth = lpeek(received_params)
	colorflip = lpeek(received_params, 4)
	inverse   = lpeek(received_params, 8)
	set_base_from_binary received_params, 12

	mes "受信した検索命令のサイズ -> " + stat

	
	割り込み = 0


	prexy = -1, -1

	result_num = 0
	nowpointer = 0

	mes "検索の最大深さ -> " + max_depth
	
    repeat set_to_array(kifulist, kifu)
		if get_value(filename_to_topnode, kifu(cnt)) == NOT_DEFINED_HASH{
			notesel sgf_data
				noteload kifu(cnt)
			noteunsel
			topnode = load_sgf(sgf_data) //棋譜読み込み
			new_value filename_to_topnode, kifu(cnt), str(topnode) //ハッシュ登録
			;dialog strf("%s -> %d", kifu(cnt), topnode)
		}else{
			topnode = int(refstr)
		}

		get_board_size_from_SGF topnode, xy


		//前回検索した棋譜とボードサイズが違う場合
		if prexy != xy || prexy.1 != xy.1{
			prexy = xy,xy.1
			//新たなパターンを生成
			make_rotate_patterns xy, xy.1
			get_pattern rotated_color, rotated_group, rotated_tejun
		
			//回転パターン数
			r_pattern_num = 4 << (xy == xy.1)

			//ヒットと判定するために必要な数
			group_num = get_pattern_all_groups_num()
			
		}
		
		//検索実行
		search_main topnode, max_depth, colorflip, rotated_color, rotated_group, rotated_tejun, r_pattern_num, group_num, path //(pathにヒットしたノードを格納

		if (path(0) >= 0) ^ inverse{
			
			nowpointer = (1024 + 64) * result_num
			result_num++
			memexpand result, (1024 + 64) * result_num
			
			memcpy result, kifu(cnt),   64, nowpointer
			memcpy result, path     , 1024, nowpointer + 64
			
		}
		
		if cnt \ 20 == 19{
			
			oncmd 0 ;メッセージジャンプ中断
			await //WM_COPYDATAを受け取る
			oncmd 1 ;再開
			if nocoCopyDataInfo(0) != count{
				//割り込みが発生してる
				割り込み = 1
				break
			}
		}
    loop

    mes "検索結果の数 -> " + result_num

	nocoSendCopyData parent_hwnd, result, 検索結果, (1024 + 64) * result_num //親プロセスに結果を送信

	if 割り込み{
		goto *on_copydata
	}
    
    swbreak


        
    case 終了指示:
        // 親プロセスからの終了指示
        mes "親プロセスから終了指示を受信しました"
        end  // プロセス終了
        swbreak

    case 接続拒否:
		mes "親プロセスに接続できませんでした"
    	end
    	swbreak
        
    default:
        mes "未知のデータタイプ: " + param
        swbreak
    swend
    
    return