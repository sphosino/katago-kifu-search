#packopt name "search_process"
#include "nodmod/ProcLinkModule.hsp"
#include "modules/rotate_coordinate.hsp"
#include "../hsp_common/id_manager.hsp"
#include "modules/bitboard.hsp"
#include "basic.hsp"
#include "modules/sgf.hsp"
#include "../hsp_common/hash.hsp"
#include "../hsp_common/set.hsp"
#include "modules/search/pattern.hsp"
#include "modules/search/Search_pattern.hsp"
#include "modules/search/Search_pattern2.hsp"
#include "メッセージ定数.hsp"

#bootopt notimer 1



screen 0,640,480,2
gsel 0,-1
view_window = 0

init_sgf_module 10000

enable_auto_adjust
set_target_wait 30
delkey_all
addkey 27, 1 //ESCをバックグラウンドでも受け付け


#ifdef _debug
	dirname = "C:\\Users\\owner\\Desktop\\katago-kifu-search"
#else
	dirname = dir_exe
#endif
chdir dirname

sdim kifulist //担当する棋譜のリスト
sdim result
newmod filename_to_topnode, hash_manager //棋譜ファイル名に、ノード展開を行った後のトップノード番号を紐づける

dim board, 26, 26
sdim v, 26 * 26 * 5
sdim group, , 4
sdim tejun, , 9

///////////////////////通信設定
// 設定読み込み
notesel s
	noteload "app_name.txt"
	// なごコネに参加。参加しなくても読み書きは可能だが、(親が離脱を感知できるようにするため）
	noteget app_name, 0
	nocoConnectAccept app_name  // グローバルアクセス空間に
	noteget h, 1
	parent_hwnd = int(h)
noteunsel
chdir "棋譜"

nocoClearCopyDataQueue (1024 + 64) * 10000 //キューのスロットサイズ設定
nocoAutoCopyData //自動ジャンプを設定（ジャンプのタイミングでモジュール内部で受信内容が保存される

kifulist = make_new_set()

// メッセージ待機
repeat
	manage_keyfps
	gosub *on_copydata
	exist_parent = 0
	repeat nocoConnectInfo(0)
		if nocoConnectInfo(1, cnt) == parent_hwnd{
			exist_parent = 1
			break
		}
	loop
	if exist_parent = 0: end
	if _getkey(27) == 1: view_window ^= 1: gsel 0, view_window*2-1
	
loop
*on_copydata
    repeat nocoCopyDataQueueCount()

		nocoGetCopyDataQueue received_data, cnt
		sender_hwnd = nocoCopyDataQueueInfo(2, cnt)
		param = nocoCopyDataQueueInfo(3, cnt)
		data_size = nocoCopyDataQueueInfo(4, cnt)

    
	    // パラメータで処理を分岐
	    switch param
	
		case 担当棋譜　//担当すべき棋譜のリストが送られてきた
			notesel received_data
				repeat notemax
					noteget a, cnt
					push_data kifulist, a
				loop
			noteunsel
		swbreak
	
	    case 検索実行
	    search_init
		
		//検索条件を取り出す
		max_depth = lpeek(received_data)
		colorflip = lpeek(received_data, 4)
		inverse   = lpeek(received_data, 8) : mes ":inverse -> " + inverse
		set_base_from_binary received_data, 12
	
		mes "受信した検索命令のサイズ -> " + stat
		
		
		prexy = -1, -1
	
		result_num = 0
		nowpointer = 0
	
		mes "検索の最大深さ -> " + max_depth
		notesel sgf_data
	    repeat set_to_array(kifulist, kifu)
			if get_value(filename_to_topnode, kifu(cnt)) == NOT_DEFINED_HASH{
				noteload kifu(cnt)
				topnode = load_sgf(sgf_data) //棋譜読み込み
				new_value filename_to_topnode, kifu(cnt), str(topnode) //ハッシュ登録
			}else{
				topnode = int(refstr)
			}
	
			get_board_size_from_SGF topnode, xy
	
	
			//前回検索した棋譜とボードサイズが違う場合
			if prexy != xy || prexy.1 != xy.1{
				prexy = xy,xy.1
				//新たなパターンを生成
				make_rotate_patterns xy, xy.1
				get_pattern rotated_color, rotated_group, rotated_tejun
			
				//回転パターン数
				r_pattern_num = 4 << (xy == xy.1)
	
				//ヒットと判定するために必要な数
				group_num = get_pattern_all_groups_num()
				
			}
			
			//検索実行
			search_main topnode, max_depth, colorflip, rotated_color, rotated_group, rotated_tejun, r_pattern_num, group_num, path //(pathにヒットしたノードを格納
			
			if (path(0) >= 0) ^ inverse{
				
				nowpointer = (1024 + 64) * result_num
				result_num++
				memexpand result, (1024 + 64) * result_num
				
				memcpy result, kifu(cnt),   64, nowpointer
				memcpy result, path     , 1024, nowpointer + 64
				
			}
		loop
		noteunsel
	    mes "検索結果の数 -> " + result_num
	
		nocoSendCopyData parent_hwnd, result, 検索結果, (1024 + 64) * result_num //親プロセスに結果を送信
	    
	    swbreak

	    case 検索実行2:
			search2_init
			mes "厳密検索開始"
	    	//検索条件を取り出す
			max_depth = lpeek(received_data)
			colorflip = lpeek(received_data, 4)
			inverse   = lpeek(received_data, 8): mes ":inverse -> " + inverse
			set_base_from_binary received_data, 12
			mes "受信した検索命令のサイズ -> " + stat

			prexy = -1, -1
			result_num = 0
			
			notesel sgf_data
	     	repeat set_to_array(kifulist, kifu)
				if get_value(filename_to_topnode, kifu(cnt)) == NOT_DEFINED_HASH{
					noteload kifu(cnt)
					topnode = load_sgf(sgf_data) //棋譜読み込み
					new_value filename_to_topnode, kifu(cnt), str(topnode) //ハッシュ登録
				}else{
					topnode = int(refstr)
				}
		
				get_board_size_from_SGF topnode, xy
		
		
				//前回検索した棋譜とボードサイズが違う場合
				if prexy != xy || prexy.1 != xy.1{
					prexy = xy,xy.1

					//新たなパターンを生成
					get_pattern rotated_color, rotated_group, rotated_tejun
					dim tmp_board, xy, xy.1
					get_base_board tmp_board
					make_pattern tmp_board, pt //回転も含めたビットボード作成
					//回転パターン数
					r_pattern_num = 4 << (xy == xy.1)

					dim mask, 23, 8
					for i,, xy //ボードx方向
					for j,, xy.1 //ボードy方向
						if tmp_board(i,j) != PATTERN_ZERO{
							for k,, r_pattern_num
								rotate_coordinate coord, i, j, k, xy, xy.1 //i,jをkによる回転を加え配列coordに格納 (coord.0 = x, coord.1 = y)
								index = (coord.1 * xy + coord.0) * 2
							    int_index = index / 32
							    bit_offset = index \ 32
							    mask(int_index, k) |= 3 << bit_offset
							next
						}
					next
					next

				}
				

				search_main2 topnode, max_depth, colorflip, r_pattern_num, mask, rotated_color, pt , path

				if (path(0) >= 0) ^ inverse{
				
					nowpointer = (1024 + 64) * result_num
					result_num++
					memexpand result, (1024 + 64) * result_num
					
					memcpy result, kifu(cnt),   64, nowpointer
					memcpy result, path     , 1024, nowpointer + 64
					
				}
			loop
			noteunsel

			mes "検索結果の数 -> " + result_num
	
			nocoSendCopyData parent_hwnd, result, 検索結果, (1024 + 64) * result_num //親プロセスに結果を送信

	    swbreak
	 
	    case 終了指示:
	        // 親プロセスからの終了指示
	        mes "親プロセスから終了指示を受信しました"
	        end  // プロセス終了
	    swbreak
	
	    case 接続拒否:
			mes "親プロセスに接続できませんでした"
	    	end
	    swbreak
	        
	    default:
	        mes "未知のデータタイプ: " + param
	        swbreak
	    swend
	loop

	nocoClearQueue
    return