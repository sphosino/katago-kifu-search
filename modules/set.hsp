#ifndef set_str
#module set_str data, hashcount, hashtable, data_deleted_list, data_deleted_list_num, data_num, valid_buckets, valid_buckets_num

#const MAX_KEYS 666667
#const FNV_PRIME 73091
#const SEED 72889

#const DEFAULT_SET_SIZE 32
    
#defcfunc local get_hash str s1

    s = SEED
    t = s1
    repeat strlen(t)
        s ^= peek(t, cnt) 
        s *= FNV_PRIME 
    loop
    return (s & 0x7FFFFFFF) \ MAX_KEYS
    
#modinit int num_maxdata ,local thismod_ID

	n = DEFAULT_SET_SIZE
	if num_maxdata > 0{
		n = limit(num_maxdata, 2)
	}
	sdim data,,n
	dim hashcount, MAX_KEYS
	dim hashtable, MAX_KEYS, 3
	dim data_deleted_list, n
	dim data_deleted_list_num
	dim valid_buckets, n
	dim valid_buckets_num

	mref thismod_ID, 2
	return thismod_ID

#modfunc set_push str s1

	hash = get_hash(s1)

	for i,, hashcount(hash)
		if data(hashtable(hash, i)) == s1{
			return 1
		}
	next

	if data_deleted_list_num{
		data_deleted_list_num--
		newid = data_deleted_list(data_deleted_list_num)
	}else{
		newid = data_num
		//２倍の拡張処理
		if newid >= length(data){
			data(newid * 2) = ""
		}
	}

	if hashcount(hash) == 0{
		valid_buckets(valid_buckets_num) = hash
		valid_buckets_num++
	}
		
	data(newid) = s1
	hashtable(hash, hashcount(hash)) = newid
	hashcount(hash)++
	
	data_num++

	return 1

#modcfunc is_in_set str s1

	hash = get_hash(s1)
	
	for i,,hashcount(hash)
		if data(hashtable(hash, i)) == s1{
			return 1
		}
	next

	return 0

#modfunc set_del str s1

	hash = get_hash(s1)
	
	for i,, hashcount(hash)
	
		dup id, hashtable(hash, i)
		
		if data(id) == s1{
			
			data_deleted_list(data_deleted_list_num) = id
			data_deleted_list_num++

			hashcount(hash)--
			id = hashtable(hash, hashcount(hash))

			if hashcount(hash) == 0{
				repeat valid_buckets_num
					if valid_buckets(cnt) == hash{
						valid_buckets_num--
						valid_buckets(cnt) = valid_buckets(valid_buckets_num)
						break
					}
				loop
			}

			data_num--
			
			return
		}
	next


#modcfunc set_get_all array result

	sdim result
	rn = 0
	repeat valid_buckets_num
		m = cnt
		repeat hashcount(valid_buckets(m))
			result(rn) = data(hashtable(valid_buckets(m), cnt))
			rn++
		loop
	loop

	return rn

#modcfunc get_cardinality
	count = 0
	repeat valid_buckets_num
		count += hashcount(valid_buckets(cnt))
	loop
	return count
#global


/////////////////////////////////////////////////////////////////////////////

#module set_manager

//新たな空のセットを作成
#defcfunc make_new_set int max ;初期確保容量
	newmod data, set_str, max
	return stat ;セットのIDを返す。

//セットに要素追加
#deffunc push_data int setID, str key

	set_push data(setID), key

	return

//セットの要素削除
#deffunc del_data int setID, str key

	set_del data(setID), key
	return

//セットの要素数取得
#defcfunc get_cardinality_set_manager int setID
	return get_cardinality(data(setID))

#defcfunc is_inset int setID, str s1
	return is_in_set(data(setID),s1)

#deffunc del_set int setID
	delmod data(setID)
	return


//セットの全データ取得
#defcfunc set_to_array int setID, array a
	return set_get_all(data(setID), a)

// セット同士の足し算
#defcfunc set_plus_set int setID, int setID2

    // 新しいセットを作成
    newSetID = make_new_set(get_cardinality(data(setID)) + get_cardinality(data(setID2)))

    // 1つ目のセットのデータを取得して追加
    
    repeat set_to_array(setID, tmp)
        push_data newSetID, tmp(cnt)
    loop

    // 2つ目のセットのデータを取得して追加
    
    repeat set_to_array(setID2, tmp)
        push_data newSetID, tmp(cnt)
    loop

    return newSetID ; 新しいセットIDを返す
    
#defcfunc set_minus_set int setID, int setID2

    // 新しいセットを作成
    newSetID = make_new_set(get_cardinality(data(setID)))

    // 1つ目のセットのデータを取得
    // `setB` に存在しない要素だけを新セットに追加
    repeat set_to_array(setID, tmp)
        if is_in_set(data(setID2), tmp(cnt)) == 0{
	        push_data newSetID, tmp(cnt)
        }
    loop

    return newSetID ; 新しいセットIDを返す

#defcfunc set_and_set int setID, int setID2

    // 新しいセットを作成
    newSetID = make_new_set(limit(get_cardinality(data(setID)),, get_cardinality(data(setID2))))

    // `setA` のデータを取得
    // `setB` にも存在するデータのみ追加
    repeat set_to_array(setID, tmp)
        if is_in_set(data(setID2), tmp(cnt)){
            push_data newSetID, tmp(cnt)
       	}
    loop

    return newSetID ; 新しいセットIDを返す

#defcfunc set_sym_diff int setID, int setID2

    newSetID = make_new_set(get_cardinality(data(setID)) + get_cardinality(data(setID2)))

    // `setA - setB`

    repeat set_to_array(setID, tmpA)
        if is_in_set(data(setID2), tmpA(cnt)) == 0{
            push_data newSetID, tmpA(cnt)
        }
    loop

    // `setB - setA`
    
    repeat set_to_array(setID2, tmpB)
        if is_in_set(data(setID), tmpB(cnt)) == 0{
            push_data newSetID, tmpB(cnt)
        }
    loop

    return newSetID

#defcfunc is_subset int setID, int setID2

    n = set_to_array(setID, tmp)
    for i,, n
        if is_in_set(data(setID2), tmp(i)) == 0{
	        return 0
        }
    next
	return 1

#defcfunc is_proper_subset int setID, int setID2
	if get_cardinality(data(setID)) >= get_cardinality(data(setID2)): return 0
	return is_subset(setID, setID2)


#defcfunc notepad_minus_notepad var s, str s2
	if s2 == "": return s
	newSetID = notepad_to_set(s2)
	
	notesel s
		result = ""
	    repeat notemax
	    	noteget tmp, cnt
	        if is_in_set(data(newSetID), tmp) == 0{
		        result += tmp + "\n"
	        }
	    loop
	noteunsel
	del_set newSetID
    return strmid(result, 0, strlen(result) - 2)
    
//---------------------------

#defcfunc array_to_set array a
	newSetId = make_new_set(length(a))
	repeat length(a)
		push_data newSetId, a(cnt)
	loop
	return newSetId

#defcfunc notepad_to_set str s1
	tmp_notepad = s1
	notesel tmp_notepad
		newSetId = make_new_set(notemax)
		repeat notemax
			noteget tmp, cnt
			push_data newSetId, tmp
		loop
	noteunsel
	return newSetId

#defcfunc set_to_notepad int setID
	s = ""
	repeat set_to_array(setID,tmp)
		s += tmp(cnt) + "\n" 
	loop
	return strmid(s,0,strlen(s)-2)
	
#global


#module
#defcfunc array_to_notepad array a

	s = ""
	repeat length(a)
		s += a.cnt
		if cnt < length(a) -1: s += "\n"
	loop
	
	return s
#defcfunc notepad_to_array str s1, array a
	s = s1
	notesel s
		sdim a
		repeat notemax
			noteget tmp, cnt
			a(cnt) = tmp
		loop
	noteunsel
	return length(a)
#global
#endif


; // set_strモジュールのテスト

#undef mes
#define global mes(%1 = "") mes@hsp %1:logmes %1

title "set_str モジュール テスト"

; // 初期化のテスト（間接的に set_manager から呼ばれるため、ここでは簡単な確認のみ）
test_module_id = make_new_set()
if test_module_id >= 0 {
    mes "set_str モジュールロード OK (ID: " + test_module_id + ")"
    del_set test_module_id
} else {
    mes "set_str モジュールロード NG"
}

; // set_managerモジュールのテスト

title "set_manager モジュール テスト"

; // make_new_set のテスト
set1_id = make_new_set()
if stat >= 0 {
    mes "make_new_set OK (ID: " + stat + ")"
    set1_id = stat
} else {
    mes "make_new_set NG"
    end
}

; // push_data のテスト
push_data set1_id, "apple"
push_data set1_id, "banana"
push_data set1_id, "cherry"
mes "push_data OK"

; // is_inset のテスト
if is_inset(set1_id, "banana") {
    mes "is_inset OK (banana が存在する)"
} else {
    mes "is_inset NG (banana が存在しない)"
}
if 0 == is_inset(set1_id, "grape") {
    mes "is_inset OK (grape が存在しない)"
} else {
    mes "is_inset NG (grape が存在する)"
}

; // set_to_array のテスト
dim array1
count1 = set_to_array(set1_id, array1)
mes "set_to_array OK (要素数: " + count1 + ")"
repeat count1
    mes "要素: " + array1(cnt)
loop

; // del_data のテスト
del_data set1_id, "banana"
if 0 == is_inset(set1_id, "banana") {
    mes "del_data OK (banana を削除)"
} else {
    mes "del_data NG (banana が削除されていない)"
}
dim array2
count2 = set_to_array(set1_id, array2)
mes "要素数: " + count2
repeat count2
    mes "要素: " + array2(cnt)
loop

; // make_new_set (初期サイズ指定) のテスト
set_sized_id = make_new_set(10)
if stat > 0 {
    mes "make_new_set (初期サイズ指定) OK (ID: " + stat + ")"
    del_set stat
} else {
    mes "make_new_set (初期サイズ指定) NG"
}

; // set_plus_set のテスト
set2_id = make_new_set()
push_data set2_id, "banana"
push_data set2_id, "grape"
set_plus_id = set_plus_set(set1_id, set2_id)
dim array_plus
count_plus = set_to_array(set_plus_id, array_plus)
mes "set_plus_set OK (要素数: " + count_plus + ")"
repeat count_plus
    mes "要素: " + array_plus(cnt)
loop
del_set set_plus_id
del_set set2_id

; // set_minus_set のテスト
set3_id = make_new_set()
push_data set3_id, "apple"
push_data set3_id, "grape"
set_minus_id = set_minus_set(set1_id, set3_id)
dim array_minus
count_minus = set_to_array(set_minus_id, array_minus)
mes "set_minus_set OK (要素数: " + count_minus + ")"
repeat count_minus
    mes "要素: " + array_minus(cnt)
loop
del_set set_minus_id
del_set set3_id

; // set_and_set のテスト
set4_id = make_new_set()
push_data set4_id, "apple"
push_data set4_id, "orange"
set_and_id = set_and_set(set1_id, set4_id)
dim array_and
count_and = set_to_array(set_and_id, array_and)
mes "set_and_set OK (要素数: " + count_and + ")"
repeat count_and
    mes "要素: " + array_and(cnt)
loop
del_set set_and_id
del_set set4_id

; // set_sym_diff のテスト
set5_id = make_new_set()
push_data set5_id, "cherry"
push_data set5_id, "grape"
set_sym_diff_id = set_sym_diff(set1_id, set5_id)
dim array_sym_diff
count_sym_diff = set_to_array(set_sym_diff_id, array_sym_diff)
mes "set_sym_diff OK (要素数: " + count_sym_diff + ")"
repeat count_sym_diff
    mes "要素: " + array_sym_diff(cnt)
loop
del_set set_sym_diff_id
del_set set5_id

; // is_subset のテスト
set6_id = make_new_set()
push_data set6_id, "apple"
is_sub1 = is_subset(set6_id, set1_id)

if is_sub1 {
    mes "is_subset OK (set6 は set1 の部分集合)"
} else {
    mes "is_subset NG (set6 は set1 の部分集合ではない)"
}
set7_id = make_new_set()
push_data set7_id, "apple"
push_data set7_id, "banana"
push_data set7_id, "grape"
is_sub2 = is_subset(set1_id, set7_id)
if is_sub2 {
    mes "is_subset OK (set1 は set7 の部分集合)"
} else {
    mes "is_subset NG (set1 は set7 の部分集合ではない)"
}
del_set set6_id
del_set set7_id

; // is_proper_subset のテスト
set8_id = make_new_set()
push_data set8_id, "apple"
is_proper1 = is_proper_subset(set8_id, set1_id)
if is_proper1 {
    mes "is_proper_subset OK (set8 は set1 の真部分集合)"
} else {
    mes "is_proper_subset NG (set8 は set1 の真部分集合ではない)"
}
is_proper2 = is_proper_subset(set1_id, set1_id)
if 0 == is_proper2 {
    mes "is_proper_subset OK (set1 は set1 の真部分集合ではない)"
} else {
    mes "is_proper_subset NG (set1 は set1 の真部分集合である)"
}
set9_id = make_new_set()
push_data set9_id, "apple"
push_data set9_id, "banana"
push_data set9_id, "cherry"
push_data set9_id, "grape"
is_proper3 = is_proper_subset(set1_id, set9_id)
if is_proper3 {
    mes "is_proper_subset OK (set1 は set9 の真部分集合)"
} else {
    mes "is_proper_subset NG (set1 は set9 の真部分集合ではない)"
}
del_set set8_id
del_set set9_id

; // notepad_minus_notepad のテスト
notepad1 = "apple\nbanana\ncherry"
notepad2 = "banana\ngrape"
result_notepad = notepad_minus_notepad(notepad1, notepad2)
mes "notepad_minus_notepad OK"
mes "結果:\n" + result_notepad

; // array_to_set のテスト
array_test.0 = "dog"
array_test.1 = "cat"
set_from_array_id = array_to_set(array_test)
dim array_from_set
tmp = set_to_array(set_from_array_id, array_from_set)
mes "array_to_set OK (要素数: " + length(array_from_set) + ")"
repeat length(array_from_set)
    mes "要素: " + array_from_set(cnt)
loop
del_set set_from_array_id

; // notepad_to_set のテスト
notepad_test = "red\ngreen\nblue"
set_from_notepad_id = notepad_to_set(notepad_test)
dim array_from_notepad
tmp = set_to_array(set_from_notepad_id, array_from_notepad)
mes "notepad_to_set OK (要素数: " + length(array_from_notepad) + ")"
repeat length(array_from_notepad)
    mes "要素: " + array_from_notepad(cnt)
loop
del_set set_from_notepad_id

; // set_to_notepad のテスト
notepad_from_set = set_to_notepad(set1_id)
mes "set_to_notepad OK"
mes "結果:\n" + notepad_from_set

; // array_to_notepad のテスト
array_to_note_test.0 = "one"
array_to_note_test.1 = "two"
notepad_from_array = array_to_notepad(array_to_note_test)
mes "array_to_notepad OK"
mes "結果:\n" + notepad_from_array

; // notepad_to_array のテスト
notepad_to_array_test = "alpha\nbeta\ngamma"
dim array_from_note_test
count_from_note = notepad_to_array(notepad_to_array_test, array_from_note_test)
mes "notepad_to_array OK (要素数: " + count_from_note + ")"
repeat count_from_note
    mes "要素: " + array_from_note_test(cnt)
loop

; // get_cardinality のテスト
cardinality = get_cardinality_set_manager(set1_id)
mes "get_cardinality OK (要素数: " + cardinality + ")"

; // 最後にセットを削除
del_set set1_id

mes "全てのテスト完了"

/*//以下結果ログです

set_str モジュールロード OK (ID: 0)
make_new_set OK (ID: 0)
push_data OK
is_inset OK (banana が存在する)
is_inset OK (grape が存在しない)
set_to_array OK (要素数: 3)
要素: apple
要素: banana
要素: cherry
del_data OK (banana を削除)
要素数: 2
要素: apple
要素: cherry
make_new_set (初期サイズ指定) OK (ID: 1)
set_plus_set OK (要素数: 4)
要素: apple
要素: cherry
要素: banana
要素: grape
set_minus_set OK (要素数: 1)
要素: cherry
set_and_set OK (要素数: 1)
要素: apple
set_sym_diff OK (要素数: 2)
要素: apple
要素: grape
is_subset OK (set6 は set1 の部分集合)
is_subset NG (set1 は set7 の部分集合ではない)
is_proper_subset OK (set8 は set1 の真部分集合)
is_proper_subset OK (set1 は set1 の真部分集合ではない)
is_proper_subset OK (set1 は set9 の真部分集合)
notepad_minus_notepad OK
結果:
apple
cherry
array_to_set OK (要素数: 2)
要素: dog
要素: cat
notepad_to_set OK (要素数: 3)
要素: red
要素: green
要素: blue
set_to_notepad OK
結果:
apple
cherry
array_to_notepad OK
結果:
onetwo

notepad_to_array OK (要素数: 3)
要素: alpha
要素: beta
要素: gamma
get_cardinality OK (要素数: 2)
全てのテスト完了

;*/