#ifndef grid_slider2
#addition "keyfps.hsp"
#module grid_slider2 area, horizontal, min, max, 長さ, 太さ, つまみサイズ, dragging_number, thumbs, thumbs_count, valid_zone_flip, state_changed,last_dragged_number

#modinit int area_number, int _min, int _max, int _horizontal, int value, local thismod_id
    //エリア番号
    area = area_number
    //スライダーの方向
    horizontal = _horizontal
    //値の変化範囲
    min = _min
    max = _max
    //バーのサイズ情報 【マイナス == 自動(エリアにピッタリ収まる）】
    長さ = -1.
    太さ = -1.
    つまみサイズ = -1.
    thumbs_count = 1
    dim thumbs, 16  //つまみの数（最大16個）
    thumbs(0) = value  //初期位置
    dragging_number = -1 //つまんでいないとき-1 : つまんでいるときその番号

    last_dragged_number = 0 //最後に操作したつまみ番号
    
    valid_zone_flip = 0 //有効区間切り替えフラグ
    
    mref thismod_id, 2
    return thismod_id

#modfunc set_size_g_slider2 double _sizex, double _sizey, double _sizer
    長さ = _sizex
    太さ = _sizey
    つまみサイズ = _sizer
    return

#modfunc add_thumb //つまみを追加する
    if thumbs_count < 16 {
        thumbs(thumbs_count) = thumbs(thumbs_count - 1)
        thumbs_count++
    }
    return

#modcfunc get_value_list array result
    //区間リストを返す
    dim result, 2
    result_count = 0
    start_point = min
    repeat thumbs_count + 1
        if cnt < thumbs_count {
            end_point = thumbs(cnt)
        } else {
            end_point = max
        }
        if cnt\2 == valid_zone_flip{
            result(0, result_count) = start_point
            result(1, result_count) = end_point
            result_count++
        }
        start_point = end_point
    loop
    
    return result_count

#modfunc slider_manager2
    get_rect area, oya　//親に矩形が取得される　x1,y1,x2,y2形式
    //--------------------------
	len = 長さ
	if 長さ < 0 {
	    if horizontal {
	        len = oya.2 - oya.0
	    } else {
	        len = oya.3 - oya.1
	    }
	} else: if 長さ > 0 && 長さ <= 1 {
	    ; パーセンテージ指定
	    if horizontal {
	        len = 長さ * (oya.2 - oya.0)
	    } else {
	        len = 長さ * (oya.3 - oya.1)
	    }
	}
	
	thickness = 太さ
	if 太さ < 0 {
	    if horizontal {
	        thickness = oya.3 - oya.1
	    } else {
	        thickness = oya.2 - oya.0
	    }
	} else: if 太さ > 0 && 太さ <= 1 {
	    ; パーセンテージ指定
	    if horizontal {
	        thickness = 太さ * (oya.3 - oya.1)
	    } else {
	        thickness = 太さ * (oya.2 - oya.0)
	    }
	}
	
	r = つまみサイズ
	if つまみサイズ < 0 {
	    r = thickness / 2
	} else: if つまみサイズ > 0 && つまみサイズ <= 1 {
	    ; パーセンテージ指定
	    r = つまみサイズ * thickness
	}
    
    // スライダーバーの描画位置計算

	; 横スライダー
	if horizontal {
		offsetx = (oya.2-oya.0 - len) / 2
		offsety = (oya.3-oya.1 - thickness) / 2
	} else {
		offsetx = (oya.2-oya.0 - thickness) / 2
		offsety = (oya.3-oya.1 - len) / 2
	}

	bar_x1 = oya.0 + offsetx
    bar_y1 = oya.1 + offsety
    bar_x2 = oya.2 - offsetx
    bar_y2 = oya.3 - offsety

	//スケール取得
	scale = absf(max-min)

	state_changed = 0

    // つまみがはみ出さないための「有効領域」を計算
    // 有効領域は中心位置の取りうる範囲（端でつまみの半径がはみ出さない）
    if horizontal {
        eff_bar_x1 = bar_x1 + r
        eff_bar_x2 = bar_x2 - r
        eff_len = limit(0, eff_bar_x2 - eff_bar_x1)
        eff_bar_y1 = bar_y1
        eff_bar_y2 = bar_y2
    } else {
        eff_bar_y1 = bar_y1 + r
        eff_bar_y2 = bar_y2 - r
        eff_len = max(0, eff_bar_y2 - eff_bar_y1)
        eff_bar_x1 = bar_x1
        eff_bar_x2 = bar_x2
    }

    // 有効区間の描画（バー本体）
    make_instant_draw_object "BOXF_FAST",bar_x1,bar_y1,bar_x2,bar_y2,"$C8C8FF"
    // 有効区間のハイライト (eff を使ってずれを吸収)
    start_point = min
    repeat thumbs_count + 1
        if cnt < thumbs_count {
            end_point = thumbs(cnt)
        } else {
            end_point = max
        }
        
if cnt\2 == valid_zone_flip {
    if horizontal {
        ; zone_x1 = eff_bar_x1 + value_to_position(start_point,min,eff_len,scale)
        ; zone_x2 = eff_bar_x1 + value_to_position(end_point,min,eff_len,scale)
        ; → 修正版：
        zone_x1 = bar_x1 + value_to_position(start_point,min,bar_x2-bar_x1,scale)
        zone_x2 = bar_x1 + value_to_position(end_point,min,bar_x2-bar_x1,scale)
        make_instant_draw_object "BOXF_FAST",zone_x1, bar_y1, zone_x2, bar_y2,"$6496FF"
    } else {
        ; zone_y1 = eff_bar_y1 + value_to_position(start_point,min,eff_len,scale)
        ; zone_y2 = eff_bar_y1 + value_to_position(end_point,min,eff_len,scale)
        ; → 修正版：
        zone_y1 = bar_y1 + value_to_position(start_point,min,bar_y2-bar_y1,scale)
        zone_y2 = bar_y1 + value_to_position(end_point,min,bar_y2-bar_y1,scale)
        make_instant_draw_object "BOXF_FAST",bar_x1, zone_y1, bar_x2, zone_y2,"$6496FF"
    }
}
        
        start_point = end_point
        
    loop
    
    // つまみの描画
    repeat thumbs_count
        thumb_val = thumbs(cnt)
        if horizontal {
            thumb_x = eff_bar_x1 + value_to_position(thumb_val,min,eff_len,scale)
            thumb_y = oya.1 + (oya.3 - oya.1) / 2
            // 描画時にも念のためクランプ（丸がはみ出さない）
            if thumb_x < eff_bar_x1: thumb_x = eff_bar_x1
            if thumb_x > eff_bar_x1 + eff_len: thumb_x = eff_bar_x1 + eff_len
        } else {
            thumb_x = oya.0 + (oya.2 - oya.0) / 2
            thumb_y = eff_bar_y1 + value_to_position(thumb_val,min,eff_len,scale)
            if thumb_y < eff_bar_y1: thumb_y = eff_bar_y1
            if thumb_y > eff_bar_y1 + eff_len: thumb_y = eff_bar_y1 + eff_len
        }
        
        // つまみの色（ドラッグ中かどうかで変える）
        if dragging_number = cnt {
            c = $FF6464
        } else {
            c = $969696
        }
        make_instant_draw_object "CIRCLE_FAST",thumb_x,thumb_y,r*2,r*2, "$FFFFFF"
        make_instant_draw_object "CIRCLE_FAST",thumb_x,thumb_y,r*2,r*2, strf("$%x,0",c)

    loop

    if dragging_number >= 0{
	    s = ""
	    repeat get_value_list(thismod, 区間)
	    	if cnt{
		    	s += "\n"
		    }
			s = "" + 区間(0,cnt) + "-" + 区間(1,cnt) 
	    loop
	    make_instant_draw_object "STR", (bar_x1+bar_x2)/2, (bar_y1 + bar_y2)/2, bar_x2 - bar_x1, bar_y2 - bar_y1, strf("%s,$224433",s)
	}
    
    // 右クリックで切り替え
    if _getkey(2) == 1 {
	   if in_rect(oya){
       	valid_zone_flip ^= 1
       	state_changed = 1
       }
    }
    
    // 入力操作
    if _getkey(1) >= 1{  // 左クリック中

        if dragging_number = -1 {  // まだつまんでいない場合
            // どのつまみがクリックされたか判定
            repeat thumbs_count
                thumb_val = thumbs(cnt)
                if horizontal {
                    thumb_x = eff_bar_x1 + value_to_position(thumb_val, min , eff_len, scale)
                    thumb_y = (oya.1 + oya.3) / 2
                    distance = (mousex - thumb_x) * (mousex - thumb_x) + (mousey - thumb_y) * (mousey - thumb_y)
                } else {
                    thumb_x = (oya.0 + oya.2) / 2
                    thumb_y = eff_bar_y1 + value_to_position(thumb_val, min , eff_len, scale)
                    distance = (mousex - thumb_x) * (mousex - thumb_x) + (mousey - thumb_y) * (mousey - thumb_y)
                }
                
                // クリック判定は半径そのものを使う（半径 r の円内）
                if distance <= (r) * (r) {
                    dragging_number = cnt
                    break
                }
            loop
        }
        
        // ドラッグ中の処理
        if dragging_number >= 0 {
            // マウス位置を有効領域にクランプしてから値に変換
            if horizontal {
                mx = mousex
                if mx < eff_bar_x1: mx = eff_bar_x1
                if mx > eff_bar_x1 + eff_len: mx = eff_bar_x1 + eff_len
                new_val = min + position_to_value(mx , eff_bar_x1, eff_len, scale) * ((min<max)*2 - 1)
            } else {
                my = mousey
                if my < eff_bar_y1: my = eff_bar_y1
                if my > eff_bar_y1 + eff_len: my = eff_bar_y1 + eff_len
                new_val = min + position_to_value(my , eff_bar_y1, eff_len, scale) * ((min<max)*2 - 1)
            }

            if min < max{
	            new_val = limit(new_val,min,max)
	        }else{
		        new_val = limit(new_val,max,min)
		    }
            
            // 他のつまみとの重複チェック
            valid = 1
            repeat thumbs_count
                if cnt != dragging_number {
                    if limit(0.02 * abs(max - min),,5) > abs(new_val - thumbs(cnt)){  // 2%以内は重複とみなす
                        valid = 0
                        break
                    }
                }
            loop
            
            if valid {
                thumbs(dragging_number) = new_val
                
                // つまみの順序を保持（ソート）
                repeat thumbs_count - 1
                    repeat thumbs_count - 1 - cnt
                    	pos1 = value_to_position(thumbs(cnt)    ,min,eff_len, scale)
                    	pos2 = value_to_position(thumbs(cnt + 1),min,eff_len, scale)
                        if pos1 > pos2 {
                            temp = thumbs(cnt)
                            thumbs(cnt) = thumbs(cnt + 1)
                            thumbs(cnt + 1) = temp
                            
                            // ドラッグ中のインデックスも更新
                            if dragging_number = cnt {
                                dragging_number = cnt + 1
                            } else : if dragging_number = cnt + 1 {
                                dragging_number = cnt
                            }
                        }
                    loop
                loop
            }
        }
    } else {
	    if dragging_number >= 0: state_changed = 1
	    last_dragged_number = dragging_number
        // クリックを離した
        dragging_number = -1
        
    }
    
    return


//util
#modcfunc is_state_changed_slider2
	return state_changed
	
#modcfunc get_last_dragged_thumb
	if dragging_number >= 0: return dragging_number
	return last_dragged_number
	
#modfunc set_value_thumb int p1, int value
	thumbs(p1) = value
	return

#modfunc set_min_max double _min, double _max
    min = _min
    max = _max
    // 必要に応じて、つまみの値を新しい範囲内に収める処理も追加
    repeat thumbs_count
        if min < max {
            thumbs(cnt) = limit(thumbs(cnt), min, max)
        } else {
            thumbs(cnt) = limit(thumbs(cnt), max, min)
        }
    loop
    return
#modcfunc get_min_max array result
    dim result, 2
    result(0) = min
    result(1) = max
    return
#modfunc remove_thumb int p1
    if thumbs_count > 1 {
        // 削除するつまみより後ろの要素を前に詰める
        repeat thumbs_count - 1 - p1
            thumbs(p1 + cnt) = thumbs(p1 + cnt + 1)
        loop
        thumbs_count--
    }
    return
//local
#defcfunc local value_to_position double value, double _min, double _len, double _scale
	//値とminを受け取り、基準点からの距離を返す
	//基準点を足すことで実際の位置になる
	if _scale == 0 :return 0
	return absf(value - _min) / _scale * _len

#defcfunc local position_to_value double position, double _pos, double _len, double _scale
	//マウス位置と基準点を受け取り、スクロールされた値を返す
	//minを足すことで実際の値になる。ただし絶対量が返るので、min > maxの時は反転させて足すこと。
	if _len == 0 :return 0
	return (position - _pos) / _len * _scale

#defcfunc local in_rect array a
    return a(0) <= mousex && a(1) <= mousey && a(2) >= mousex && a(3) >= mousey

#global
#endif
