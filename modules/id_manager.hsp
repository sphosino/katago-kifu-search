#ifndef id_manager
#module id_manager used_list, used_list_num, open_list, open_list_num, id_position_in_used_list, using_max

#modinit
	dim used_list
	used_list_num = 0

	open_list = 0
	open_list_num = 1

	using_max = 1

	dim id_position_in_used_list

	return

#modcfunc get_new_id
	if open_list_num {
		open_list_num--
		new_id = open_list(open_list_num)
	} else {
		new_id = using_max
		using_max++
	}

	used_list(used_list_num) = new_id
	id_position_in_used_list(new_id) = used_list_num + 1 ; 1スタート
	used_list_num++

	return new_id

#modfunc release_id int id
	if id >= using_max : return

	dup idx, id_position_in_used_list(id)
	if idx {
		open_list(open_list_num) = id
		open_list_num++

		used_list_num--
		move_id = used_list(used_list_num)
		used_list(idx - 1) = move_id
		id_position_in_used_list(move_id) = idx
		idx = 0
	}
	return

#modcfunc is_id_alive int id //生存確認！
	return id_position_in_used_list(id) > 0

#modcfunc get_used_ids array a
	dim a, used_list_num
	memcpy a, used_list, used_list_num << 2
	return used_list_num

#modcfunc get_using_count //カウントだけほしい時はこれ！
	return used_list_num
	
#global

#define global foreach_id(%1, %2)%tforeach_id repeat get_used_ids(%1,tmp@id_manager): %2 = tmp@id_manager(cnt)
#define global foreach_end %tforeach_id loop
#endif

//マクロテスト
#if 0
newmod a,id_manager

e = get_new_id(a)
f = get_new_id(a)

foreach_id a,l
	mes l
foreach_end


#endif