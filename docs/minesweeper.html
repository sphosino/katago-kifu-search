<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ï¼ˆæ——ã¤ãï¼‰</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
    }
    #board {
      display: inline-grid;
      grid-template-columns: repeat(10, 30px);
      gap: 2px;
      margin-top: 20px;
    }
    .cell {
      width: 30px;
      height: 30px;
      background-color: #ccc;
      border: 1px solid #999;
      cursor: pointer;
      line-height: 30px;
      font-size: 16px;
      user-select: none;
    }
    .revealed {
      background-color: #eee;
      cursor: default;
    }
    .mine {
      background-color: red;
    }
  </style>
</head>
<body>
  <h1>ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ï¼ˆæ——ã¤ãï¼‰</h1>
  <button onclick="init()">ãƒªã‚»ãƒƒãƒˆ</button>
  <div id="board"></div>

  <script>
    const size = 10;
    const mineCount = 10;
    let board = [];
    let mineSet = new Set();
    let revealed = new Set();
    let flagged = new Set();
    let firstClick = true;
    let questionSet = new Set();  // â† ï¼Ÿãƒã‚¹ã®åº§æ¨™ãƒªã‚¹ãƒˆ
let questionCount = 10;       // â† ï¼Ÿã«ã™ã‚‹ãƒã‚¹ã®æ•°ï¼ˆè‡ªç”±ã«å¤‰æ›´OKï¼‰
  
  // ï¼Ÿãƒã‚¹ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é¸æŠ
  function generateQuestionMarks(sx, sy) {
    let attempts = 0;
    questionSet.clear();
    while (questionSet.size < questionCount && attempts < 100) {
      // ãƒ©ãƒ³ãƒ€ãƒ ãªåº§æ¨™ã‚’ç”Ÿæˆ
      // åœ°é›·ã®ä½ç½®ã‚’é¿ã‘ã‚‹
      const x = Math.floor(Math.random() * size);
      const y = Math.floor(Math.random() * size);
      const key = `${x},${y}`;
      attempts++;
      // ã™ã§ã«ï¼Ÿãƒã‚¹ã¾ãŸã¯åœ°é›·ã®ä½ç½®ã‚’é¿ã‘ã‚‹
      if (mineSet.has(key)) continue;  // åœ°é›·ã®ä½ç½®ã‚’é¿ã‘ã‚‹
      if (Math.abs(x - sx) <= 1 && Math.abs(y - sy) <= 1) continue; // åˆæ‰‹ã®å‘¨å›²ã‚’é¿ã‘ã‚‹
      if (countMines(x, y) === 0) continue;
      questionSet.add(key);
      
    }
  }
  // ï¼Ÿãƒã‚¹ã‚’è¡¨ç¤º
  function showQuestionMarks() {
    questionSet.forEach(key => {
      const [x, y] = key.split(",").map(Number);
      const cell = board[y][x];
      cell.textContent = "?";
    });
  }
  function init() {
    firstClick = true;
    board = [];
    mineSet.clear();
    revealed.clear();
    flagged.clear();
    questionSet.clear();  // â† ï¼Ÿãƒã‚¹ã®åº§æ¨™ãƒªã‚¹ãƒˆã‚’ã‚¯ãƒªã‚¢
    const boardDiv = document.getElementById("board");
    boardDiv.innerHTML = "";
    boardDiv.style.gridTemplateColumns = `repeat(${size}, 30px)`;

    for (let y = 0; y < size; y++) {
      board[y] = [];
      for (let x = 0; x < size; x++) {
        const cell = document.createElement("div");
        cell.className = "cell";
        cell.dataset.x = x;
        cell.dataset.y = y;
        cell.onclick = onLeftClick;
        cell.oncontextmenu = onRightClick;
        cell.onmousedown = onMiddleClick;  // â† ä¸­ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆè¿½åŠ 
        board[y][x] = cell;
        boardDiv.appendChild(cell);
      }
    }
  }

  // ä¸­ã‚¯ãƒªãƒƒã‚¯ã«ã‚ˆã‚‹è‡ªå‹•é–‹å°å‡¦ç†
  function onMiddleClick(e) {
    if (e.button !== 1) return; // ä¸­ã‚¯ãƒªãƒƒã‚¯ï¼ˆãƒ›ã‚¤ãƒ¼ãƒ«æŠ¼ã—è¾¼ã¿ï¼‰é™å®š

    const x = parseInt(e.target.dataset.x);
    const y = parseInt(e.target.dataset.y);
    const key = `${x},${y}`;
    const cell = board[y][x];

    if (!revealed.has(key)) return;

    const num = parseInt(cell.textContent);
    if (isNaN(num) || num === 0) return;

    let flagCount = 0;
    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        const nx = x + dx;
        const ny = y + dy;
        if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
          if (flagged.has(`${nx},${ny}`)) flagCount++;
        }
      }
    }

    if (flagCount === num) {
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            const neighborKey = `${nx},${ny}`;
            if (!flagged.has(neighborKey)) {
              onLeftClick({ target: board[ny][nx] });
            }
          }
        }
      }
    }
  }

function onLeftClick(e) {
  const x = parseInt(e.target.dataset.x);
  const y = parseInt(e.target.dataset.y);
  const key = `${x},${y}`;

  if (flagged.has(key) || revealed.has(key)) return;

  // æœ€åˆã®ã‚¯ãƒªãƒƒã‚¯æ™‚ã«åœ°é›·ã‚’é…ç½®
  if (firstClick) {
    generateMines(x, y);
    firstClick = false;
    generateQuestionMarks(x, y);  // ï¼Ÿãƒã‚¹ã‚’ç”Ÿæˆ
  }
  if (mineSet.has(key)) {
    revealAllMines();
    alert("ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼");
    return;
  }
  reveal(x, y)
    // ğŸ‰ ã“ã“ãŒè¿½åŠ ãƒã‚¤ãƒ³ãƒˆï¼
    if (revealed.size === size * size - mineCount) {
    alert("ã‚¯ãƒªã‚¢ï¼ãŠã‚ã§ã¨ã†ğŸ‰");
  }
}
// åˆæ‰‹ã‚’é¿ã‘ã¦åœ°é›·ã‚’é…ç½®
function generateMines(sx, sy) {
  mineSet.clear();
  while (mineSet.size < mineCount) {
    const x = Math.floor(Math.random() * size);
    const y = Math.floor(Math.random() * size);

    // åˆæ‰‹ï¼ˆsx, syï¼‰ã¨ãã®å‘¨å›²ã‚’é¿ã‘ã‚‹
    if (Math.abs(x - sx) <= 1 && Math.abs(y - sy) <= 1) continue;

    mineSet.add(`${x},${y}`);
  }
}

function onRightClick(e) {
  e.preventDefault();
  const x = parseInt(e.target.dataset.x);
  const y = parseInt(e.target.dataset.y);
  const key = `${x},${y}`;
  const cell = board[y][x];

  if (revealed.has(key)) return;

  if (flagged.has(key)) {
    flagged.delete(key);
    cell.textContent = "";
  } else {
    flagged.add(key);
    cell.textContent = "ğŸš©";
  }
}

function reveal(x, y) {
  const key = `${x},${y}`;
  if (revealed.has(key) || x < 0 || y < 0 || x >= size || y >= size || flagged.has(key)) return;
  const cell = board[y][x];
  revealed.add(key);
  cell.classList.add("revealed");

  let count = countMines(x, y);
  if (questionSet.has(key)) {
    cell.textContent = "?";  // ï¼Ÿãƒã‚¹ã‚’è¡¨ç¤º
  }else if (count > 0) {
    cell.textContent = count;
  } else {
    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        if (dx !== 0 || dy !== 0) {
          reveal(x + dx, y + dy);
        }
      }
    }
  }
}

function countMines(x, y) {
  let count = 0;
  for (let dx = -1; dx <= 1; dx++) {
    for (let dy = -1; dy <= 1; dy++) {
      if (dx !== 0 || dy !== 0) {
        const nx = x + dx;
        const ny = y + dy;
        if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
          if (mineSet.has(`${nx},${ny}`)) count++;
        }
      }
    }
  }
  return count;
}

function revealAllMines() {
  mineSet.forEach(key => {
    const [x, y] = key.split(",").map(Number);
    const cell = board[y][x];
    cell.classList.add("mine");
    cell.textContent = "ğŸ’£";
  });
}

init();

    // ğŸ”’ å³ã‚¯ãƒªãƒƒã‚¯ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’å®Œå…¨ã«æŠ‘åˆ¶
    document.addEventListener("contextmenu", e => e.preventDefault());
  </script>
</body>
</html>